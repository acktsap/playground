# Engineering

## Rule

0. 코드에 꿈과 희망을..!
1. 알았던 거지만 까먹은 뭔가 발생하면 그거 다 다시 복습.
2. 새로운 지식 떠오르는거 다 queue에 쌓아뒀다가 집가서 (또는 여유시간에) 처리.
3. 프로젝트 할 때마다 커리어 정리.
4. 이 기술을 왜 쓰는가? 장단점은? 대안은?

## Programming

The process of creating a set of instructions that tell a computer how to perform a task.

It require **abstraction**. Which removes unnecessary things from our concerns.

Abstraction is modeling some processing to solve some problem as a language of computational world.

Then programming is creating a set of instruction for solving some problem based on model.

## Seperation of Concerns

Modeling per concerns

- Minimize modification on a spec changes
- Maximize reuseability

It represents as **SOLID** in OOP

- Single Responsibility Principle : A class should only have a single responsibility. One changes to spec affects to an one class.
- Open-Closed Principle : Open for extension and closed for modification
- Liskov Substitution Principle : Objects should be replaceable with instances of their subtypes without modification
- Interface Segregation Principle : Many client-specific interfaces are better than one general-purpose interface
- Dependency Inversion Principle : One should depend upon abstractions not concretions (eg. dependency injection)

## Everything is for human

**Technology** is for human. It should solve some problem human is struggle with.

Human can handle a little information at the same time. Apply KISS (Keep It Simple Stupid) on code.

Simple is best. Don't make a dependency if possible.

## Engineering Mind

Solve problem **in a effective way**. Increase performence, in a simple way.

Engineering is understanding performance, structure, limits of what you build, deeply

## Tech

- History (What for?)
- Pros, Cons
- Comparision

## Questions

- What kind of problem does it solve? No alternatives for this one?
- Is it simple enough? fancy? beautiful?
- Is is effective enough?
- What kind of stuffs need to be changed when spec changes?
